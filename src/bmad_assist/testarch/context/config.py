"""TEA context loader configuration models.

This module defines Pydantic configuration models for the TEA context
loader, controlling which artifacts are injected into which workflows.

Addresses:
- ADR-1: Config location (extends TestarchConfig)
- ADR-9: Config access strategy (constructor injection)
- F4 Fix: Backward compatibility (enabled=True by default)
- F12 Fix: Empty include list disables artifacts for workflow
- F13 Fix: Pydantic validation for artifact types
"""

from __future__ import annotations

import logging

from pydantic import BaseModel, ConfigDict, Field, field_validator

from bmad_assist.testarch.paths import VALID_ARTIFACT_TYPES

logger = logging.getLogger(__name__)


class TEAContextWorkflowConfig(BaseModel):
    """Per-workflow artifact configuration.

    Specifies which TEA artifacts should be loaded for a specific workflow.

    Attributes:
        include: List of artifact types to include for this workflow.
            Valid types: test-design, atdd, test-review, trace.
            Empty list means no artifacts for this workflow.

    Examples:
        ```yaml
        dev_story:
          include: [test-design, atdd]
        code_review:
          include: []  # Explicitly disable TEA context
        ```

    """

    model_config = ConfigDict(frozen=True)

    include: list[str] = Field(
        default_factory=list,
        description="Artifact types to include for this workflow",
        json_schema_extra={
            "security": "safe",
            "ui_widget": "checkbox_group",
            "options": list(VALID_ARTIFACT_TYPES),
        },
    )

    @field_validator("include", mode="after")
    @classmethod
    def validate_artifact_types(cls, v: list[str]) -> list[str]:
        """Validate that all artifact types are valid."""
        if not v:
            return v  # Empty list is valid (F12 Fix)

        invalid = set(v) - VALID_ARTIFACT_TYPES
        if invalid:
            raise ValueError(
                f"Invalid artifact types: {sorted(invalid)}. "
                f"Valid types: {sorted(VALID_ARTIFACT_TYPES)}"
            )
        return v


class TEAContextConfig(BaseModel):
    """TEA context loader configuration.

    Controls TEA artifact context injection into workflow compilers.
    When enabled, artifacts generated by TEA workflows (test-design,
    ATDD checklists, test-review, trace matrix) are loaded and injected
    into compiled prompts based on per-workflow configuration.

    BACKWARD COMPATIBILITY (F4 Fix):
    - enabled: true by default (matches existing hardcoded ATDD behavior)
    - Default workflows mimic current behavior so existing projects work
    - Projects without this config section fall back to legacy ATDD loading

    Attributes:
        enabled: Master switch for TEA context loading.
        budget: Total token budget across all artifacts.
        max_tokens_per_artifact: Cap per single artifact.
        max_files_per_resolver: Cap for multi-file artifacts (ATDD).
        workflows: Per-workflow artifact configuration.

    Example:
        ```yaml
        testarch:
          context:
            enabled: true
            budget: 8000
            max_tokens_per_artifact: 4000
            max_files_per_resolver: 10
            workflows:
              dev_story:
                include: [test-design, atdd]
              code_review:
                include: [test-design]
              code_review_synthesis:
                include: [test-review]
              retrospective:
                include: [trace]
        ```

    """

    model_config = ConfigDict(frozen=True)

    enabled: bool = Field(
        default=True,  # F4 Fix: Default TRUE for backward compatibility
        description="Master switch for TEA context loading",
        json_schema_extra={"security": "safe", "ui_widget": "toggle"},
    )

    budget: int = Field(
        default=8000,
        ge=0,
        description="Total token budget across all artifacts",
        json_schema_extra={"security": "safe", "ui_widget": "number"},
    )

    max_tokens_per_artifact: int = Field(
        default=4000,
        ge=0,
        description="Cap per single artifact (prevents one artifact eating budget)",
        json_schema_extra={"security": "safe", "ui_widget": "number"},
    )

    max_files_per_resolver: int = Field(
        default=10,
        ge=1,
        le=100,
        description="Cap for multi-file artifacts (currently only applies to ATDDResolver)",
        json_schema_extra={"security": "safe", "ui_widget": "number"},
    )

    # Default workflows mimic current hardcoded behavior (F4 Fix)
    workflows: dict[str, TEAContextWorkflowConfig] = Field(
        default_factory=lambda: {
            "dev_story": TEAContextWorkflowConfig(include=["test-design", "atdd"]),
            "code_review": TEAContextWorkflowConfig(include=["test-design"]),
            "code_review_synthesis": TEAContextWorkflowConfig(include=["test-review"]),
            "retrospective": TEAContextWorkflowConfig(include=["trace"]),
        },
        description="Per-workflow artifact configuration",
    )

    def get_workflow_config(self, workflow_name: str) -> TEAContextWorkflowConfig | None:
        """Get workflow config, return None for unknown workflows.

        Args:
            workflow_name: Workflow identifier (e.g., "dev_story").

        Returns:
            Workflow config or None if not configured.
            None means no artifacts should be loaded (not an error).

        """
        return self.workflows.get(workflow_name)
